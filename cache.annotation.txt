--------------------------------------------------------------------------------
I1 cache:         16384 B, 32 B, 8-way associative
D1 cache:         8192 B, 64 B, 4-way associative
L2 cache:         524288 B, 64 B, 8-way associative
Command:          /usr/bin/python2.2 /home/kpalin/tyot/comparative/mabs/mabs -as Nmyc.Enhancer.50kBp.ENSMUSG00000037169.fa -as Nmyc.Enhancer.50kBp.ENSG00000134323.fa -align tmp.gff
Events recorded:  Ir I1mr I2mr Dr D1mr D2mr Dw D1mw D2mw
Events shown:     Ir I1mr I2mr Dr D1mr D2mr Dw D1mw D2mw
Event sort order: D2mr
Thresholds:       99
Include dirs:     /home/kpalin/tyot/comparative/mabs/src/
                  /usr/include/c++/3.2.2/bits/
User annotated:   align.cc
                  stl_vector.h
Auto-annotation:  off

--------------------------------------------------------------------------------
            Ir      I1mr   I2mr            Dr        D1mr    D2mr          Dw      D1mw    D2mw 
--------------------------------------------------------------------------------
12,653,252,455 7,684,294 18,225 5,170,877,776 213,052,041 487,206 942,486,966 1,146,902 269,143  PROGRAM TOTALS

--------------------------------------------------------------------------------
           Ir      I1mr  I2mr            Dr        D1mr    D2mr          Dw    D1mw    D2mw  file:function
--------------------------------------------------------------------------------
    5,865,519         6     1       847,530     211,969 210,379         175       0       0  stl_vector.h:alignment_nextBest(align_AlignmentObject*)
    5,958,760         1     0     2,383,504      84,123  74,185   2,383,504 125,445 108,014  new:_ZSt24__uninitialized_copy_auxIN9__gnu_cxx17__normal_iteratorIPK11matrixentrySt6vectorIS2_SaIS2_EEEEPS2_ET0_T_SB_SA_12__false_type
2,220,521,985       309   100   994,431,243  47,288,114  50,378 192,396,175 314,817  70,200  stl_vector.h:alignObject(align_AlignmentObject*)
1,932,368,145       135    39   620,477,052 133,141,325  25,386  76,130,952 288,728       0  stl_vector.h:indexYBeforeOrAtBp(int, __CPSTUF*, double)
      627,056        27     0       156,764      68,769  16,208      78,382   3,864   3,855  basic_string.h:triple::triple(triple const&)
    3,737,502    43,350     9     1,107,408      43,257  12,885   1,245,834       0       0  ???:std::string::~string()
    2,008,686         2     1     1,120,778      79,787   8,698     655,038       0       0  basic_string.h:std::_Rb_tree<std::string, std::pair<std::string const, unsigned>, std::_Select1st<std::pair<std::string const, unsigned> >, std::less<std::string>, std::allocator<std::pair<std::string const, unsigned> > >::lower_bound(std::string const&)
    2,098,042     4,493    36       732,922      15,131   6,663     513,866   4,001     615  ???:_int_free
    2,257,208         4     1     1,236,165      70,742   5,533     718,807       0       0  basic_string.h:std::_Rb_tree<std::string, std::pair<std::string const, unsigned>, std::_Select1st<std::pair<std::string const, unsigned> >, std::less<std::string>, std::allocator<std::pair<std::string const, unsigned> > >::find(std::string const&)
    1,349,237         6     5       555,340       8,283   5,446     356,171       1       0  stl_tree.h:std::_Rb_tree<std::string, std::pair<std::string const, unsigned>, std::_Select1st<std::pair<std::string const, unsigned> >, std::less<std::string>, std::allocator<std::pair<std::string const, unsigned> > >::find(std::string const&)
    2,037,932       107     6       940,584      14,093   5,344     783,820   8,409   7,735  stl_construct.h:triple::triple(triple const&)
    1,661,283       576    75       767,501     113,718   4,911     214,823     373      14  ???:do_lookup_versioned
    1,684,479       509    12       757,479      31,238   4,017     268,373      21       8  ???:strcmp
    3,638,358        12     9       167,303       3,962   3,924      21,421       0       0  align.cc:alignment_nextBest(align_AlignmentObject*)
      705,040        21    11       251,799       3,699   3,635     201,726      41       1  stl_vector.h:align_alignCommon(_object*, _object*, std::istream*)
    1,139,696         1     0       166,828      37,155   3,608           .       .       .  align.cc:__gnu_cxx::__normal_iterator<triple*, std::vector<triple, std::allocator<triple> > > std::__unguarded_partition<__gnu_cxx::__normal_iterator<triple*, std::vector<triple, std::allocator<triple> > >, triple>(__gnu_cxx::__normal_iterator<triple*, std::vector
    1,543,674    43,742     4       872,671       5,098   2,910     204,323       0       0  ???:std::string::compare(std::string const&) const
    2,349,487     1,545    26     1,001,385      33,172   2,464     438,788   1,289      71  ???:lookdict_string
      311,262         8     0       123,827       9,955   2,155      39,712       0       0  ???:visit_decref
    1,251,264         3     2       395,136      26,581   2,130     197,568       0       0  ???:std::string::_Rep::_M_grab(std::allocator<char> const&, std::allocator<char> const&)
      406,495       265    53       174,066      12,130   2,026      68,830   2,614     124  ???:elf_dynamic_do_rel.7
    1,215,626       118    15       471,990       7,386   1,904     155,802      23       1  ???:PyDict_Next
      633,282       244    46       284,207      43,684   1,873      91,513      29       1  ???:do_lookup
    1,248,313         4     3       518,227       5,659   1,823     330,944      19       2  stl_tree.h:std::_Rb_tree<std::string, std::pair<std::string const, unsigned>, std::_Select1st<std::pair<std::string const, unsigned> >, std::less<std::string>, std::allocator<std::pair<std::string const, unsigned> > >::lower_bound(std::string const&)
1,847,506,051       686   102 1,076,479,888   7,078,552   1,751           2       0       0  stl_iterator.h:alignObject(align_AlignmentObject*)
    2,247,119         1     0     1,485,037      19,334   1,750           .       .       .  char_traits.h:std::_Rb_tree<std::string, std::pair<std::string const, unsigned>, std::_Select1st<std::pair<std::string const, unsigned> >, std::less<std::string>, std::allocator<std::pair<std::string const, unsigned> > >::find(std::string const&)
       14,406         4     4         5,764       2,739   1,546       2,878       0       0  ???:update_refs
   11,798,050    45,494    30     4,995,826      30,460   1,474   3,259,438  15,393   3,874  ???:memcpy
      114,926         2     1        65,724       1,576   1,378       8,191       0       0  stl_iterator.h:_ZSt24__uninitialized_copy_auxIN9__gnu_cxx17__normal_iteratorIPSt6vectorI11matrixentrySaIS3_EES2_IS5_SaIS5_EEEES9_ET0_T_SB_SA_12__false_type
      904,024     1,349    15       449,968       9,989   1,026     113,514       0       0  ???:strlen
    1,103,341       392    65       156,898       4,304     986      65,738      68      15  ???:_dl_lookup_versioned_symbol_internal
       51,742       401    19        15,493       1,912     897      11,965       3       0  ???:code_dealloc
      103,297       249    17        23,670       4,043     890      11,225       6       0  ???:dict_dealloc
    1,736,590     3,262    22       444,253      12,306     809     363,467   1,276       4  ???:__libc_free
    1,010,979         1     1        16,382       1,090     806           .       .       .  stl_construct.h:std::vector<matrixentry, std::allocator<matrixentry> >::~vector()
  114,171,346   706,766 1,539   111,545,878     728,730     731     891,893   7,056      18  ???:???
    6,168,918    27,240   577     2,440,997      39,740     705     807,426   1,765      40  ???:eval_frame
      447,788     3,089    24       135,030      11,956     699      79,610       4       0  ???:tupledealloc
      175,667        14     8        68,236       3,015     677      55,292       0       0  ???:_PyModule_Clear
      294,876         1     0       163,820       8,156     632     131,056   8,190   8,159  stl_construct.h:__gnu_cxx::__normal_iterator<id_triple*, std::vector<id_triple, std::allocator<id_triple> > > std::__uninitialized_copy_aux<__gnu_cxx::__normal_iterator<id_triple*, std::vector<id_triple, std::allocator<id_triple> > >, __gnu_cxx::__normal_iterator<id_trip
    7,424,002    10,851   104     2,494,948      32,551     490   1,128,490  39,656  16,815  ???:_int_malloc
       80,700       332     5        58,910       2,587     436      54,638   3,019     739  ???:__GI___mempcpy
      652,355       961    15       242,734       1,920     404     186,106     352      33  ???:insertdict
      163,745         1     1        49,146         510     398      57,292       0       0  stl_vector.h:std::vector<matrixentry, std::allocator<matrixentry> >::~vector()
      126,154        45    11        65,389       2,795     386      46,896   2,065     987  ???:memmove
      294,886       440     5       140,846       5,601     358      46,212     120      16  ???:_PyString_Eq
       26,275       230    25         9,356         728     348       6,492     401     151  ???:func_dealloc
       57,582         7     3        15,872       3,047     327      22,457       2       0  ???:PyString_Fini
      406,646       268    34        70,955       2,333     280      33,261      33       1  ???:_dl_lookup_symbol_internal
   23,225,185    58,298    11     7,151,514     159,418     279   4,513,789  16,755       3  ???:std::__default_alloc_template<true, 0>::allocate(unsigned)
        7,446       153    20         2,962         949     274       1,428      32       3  ???:fixup
       36,799        12     7        15,897         524     260       8,958       1       0  ???:history_do_write
      813,682       257    15       283,764         802     238     116,734     308      45  ???:r_long
       90,793        12     8        41,399         209     204       3,008       0       0  ???:read_history_range
       32,240       516    30         9,665       1,383     201      11,598      60       0  ???:PyFunction_New
      273,894        11     7        68,278         960     185      57,816       2       1  ???:tupletraverse
       74,810       168     9        30,512       2,758     171      13,562       0       0  ???:PyParser_AddToken
    3,358,656         7     4       987,840       3,032     168   1,119,552       0       0  ???:std::string::assign(std::string const&)
        4,181         5     3         1,362         168     167         844       1       1  ???:PyGrammar_RemoveAccelerators
      797,457     2,586    11       320,879       6,426     165     227,694     382      43  ???:PyDict_GetItem
       17,790        20    11         7,429         250     154       1,674       0       0  ???:_dl_fini
       29,898       128    25         7,057         635     154       5,754       0       0  ???:add_operators
    1,187,375    43,576     5       386,109       6,227     146     266,523       0       0  ???:std::string::_Rep::_M_dispose(std::allocator<char> const&)
      547,156    13,429   586       176,823       2,886     137     128,137   1,861     106  ???:_IO_vfprintf_internal
      220,425     1,603    15        85,043       5,089     137      56,024     661      23  ???:malloc_consolidate
       16,104       767    83         5,329         651     135       2,199      44       0  ???:_dl_map_object_from_fd
        9,985        69    16         3,893         414     132         232       4       1  ???:__GI_getenv
      197,566       237    30        56,346       4,650     126      47,070     107       9  ???:_dl_name_match_p
       17,223       311    84         5,800       1,213     126       3,773      50       4  ???:_dl_map_object_internal
        8,858        13     7         3,363         231      93       2,139       0       0  ???:PyDict_Clear
      348,572       134    45        92,952         773      93      96,826     284      26  ???:_IO_fwrite_internal

--------------------------------------------------------------------------------
-- User-annotated source: /home/kpalin/tyot/comparative/mabs/src/ + align.cc
--------------------------------------------------------------------------------
         Ir   I1mr I2mr          Dr       D1mr  D2mr          Dw   D1mw D2mw 

-- line 70 ----------------------------------------
          .      .    .           .          .     .           .      .    .    double pos;
          .      .    .           .          .     .           .      .    .    double epos;
          .      .    .           .          .     .           .      .    .    //uint pos;
          .      .    .           .          .     .           .      .    .    double weight;
          .      .    .           .          .     .           .      .    .    char strand;
          .      .    .           .          .     .           .      .    .  };
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  // Needed for sort
  1,605,578      7    4     327,909     37,917 3,612       3,050      0    0  bool operator<(const triple& t1, const triple& t2){
          .      .    .           .          .     .           .      .    .    return t1.epos<t2.epos || (t1.epos==t2.epos && t1.weight<t2.weight);
          .      .    .           .          .     .           .      .    .  }
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  typedef map<string, vector<triple> > matchlisttype;
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  struct matrixentry
          .      .    .           .          .     .           .      .    .  {
          .      .    .           .          .     .           .      .    .    store value;
-- line 86 ----------------------------------------
-- line 100 ----------------------------------------
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  //returns the square of a mod 2 PI double
          .      .    .           .          .     .           .      .    .  inline double squaremod(double val)
 92,297,349      0    0  30,765,783          0     0           .      .    .  {
          .      .    .           .          .     .           .      .    .    double f=fabs(val);
399,955,179      2    0  92,297,349          0     0 153,828,915  7,080    3    f-=2*PI*trunc(f/(2*PI));
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  #ifndef NDEBUG
          .      .    .           .          .     .           .      .    .    double apuf=fabs(val);
          .      .    .           .          .     .           .      .    .    apuf-=2*PI*round(apuf/(2*PI));
          .      .    .           .          .     .           .      .    .    if(apuf>PI) apuf-= 2*PI;
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .    if(f>(PI+1e9) || f<(-PI-1e9)) {
          .      .    .           .          .     .           .      .    .      printf("f=%g!=%g=PI\n",f,PI);
          .      .    .           .          .     .           .      .    .    }
          .      .    .           .          .     .           .      .    .  #endif
          .      .    .           .          .     .           .      .    .    assert(fabs(f-apuf)<1e9);
          .      .    .           .          .     .           .      .    .    assert(f<(PI+1e9));
 30,765,783      0    0           .          .     .           .      .    .    assert(f>(-PI-1e9));
          .      .    .           .          .     .           .      .    .    return f * f;
          .      .    .           .          .     .           .      .    .  }
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  inline double anglepenalty(double const d,double const D,double const nucl_per_rotation)
184,594,698      0    0  92,297,349          0     0           .      .    .  {
123,063,132      0    0  61,531,566          0     0           .      .    .    double const theta=(d-D)*2.0*PI/nucl_per_rotation;
          .      .    .           .          .     .           .      .    .    return squaremod(theta)/(d+D);
          .      .    .           .          .     .           .      .    .  }
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
-- line 137 ----------------------------------------
-- line 149 ----------------------------------------
          .      .    .           .          .     .           .      .    .          pos = str.find_first_of(delimiters, lastPos);
          .      .    .           .          .     .           .      .    .      }
          .      .    .           .          .     .           .      .    .      return tokens;
          .      .    .           .          .     .           .      .    .  }
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  // Dirty trick. Requires references.
          .      .    .           .          .     .           .      .    .  int parseLine(string const line,triple &tri,string &sequence)
    116,192 29,048    4           .          .     .      72,620      0    0  {
          .      .    .           .          .     .           .      .    .    string TF;
          .      .    .           .          .     .           .      .    .    int pos,epos;
          .      .    .           .          .     .           .      .    .    double weight;
          .      .    .           .          .     .           .      .    .    char strand;
          .      .    .           .          .     .           .      .    .    istringstream help(line);
          .      .    .           .          .     .           .      .    .    if (! (help >> sequence))
          .      .    .           .          .     .           .      .    .      {
          .      .    .           .          .     .           .      .    .  #ifdef ALIGN_OUTPUT
-- line 165 ----------------------------------------
-- line 205 ----------------------------------------
          .      .    .           .          .     .           .      .    .      {
          .      .    .           .          .     .           .      .    .  #ifdef ALIGN_OUTPUT
          .      .    .           .          .     .           .      .    .        cerr<<"wrong format in strand part:"<<endl
          .      .    .           .          .     .           .      .    .  	  <<line<<endl;
          .      .    .           .          .     .           .      .    .  #endif
          .      .    .           .          .     .           .      .    .        return 0;
          .      .    .           .          .     .           .      .    .      }
          .      .    .           .          .     .           .      .    .    tri.TF = TF;
     43,572 14,524    1      29,048          0     0      14,524      0    0    tri.pos=pos;
     72,620      0    0      43,572          0     0      29,048  1,765    0    tri.weight=weight;
     29,048    184    0      14,524          0     0      14,524      0    0    tri.epos=epos;
     29,048      0    0      14,524          0     0      14,524      0    0    tri.strand=strand;
          .      .    .           .          .     .           .      .    .    return 1;
     87,144 14,524    1      72,620          0     0           .      .    .  }
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  // this function parses a file in gff format
          .      .    .           .          .     .           .      .    .  matchlisttype* parseStream(istream *in)
          8      2    2           .          .     .           5      0    0  {
          3      0    0           .          .     .           2      1    0    matchlisttype* matchlist=new matchlisttype;
          .      .    .           .          .     .           .      .    .    if (!*in) 
          .      .    .           .          .     .           .      .    .      {
          .      .    .           .          .     .           .      .    .        #ifdef ALIGN_OUTPUT
          .      .    .           .          .     .           .      .    .        cerr << "Error while parsing GFF data"<< endl;
          .      .    .           .          .     .           .      .    .        #endif
          .      .    .           .          .     .           .      .    .        return matchlist;      
          .      .    .           .          .     .           .      .    .      }
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .    string line,sequence;
     76,304      0    0           .          .     .      76,304      0    0    triple tri;
          2      0    0           .          .     .           1      1    0    while(getline(*in, line))
          .      .    .           .          .     .           .      .    .    {
          .      .    .           .          .     .           .      .    .      if(parseLine(line,tri,sequence)) {
          .      .    .           .          .     .           .      .    .        (*matchlist)[sequence].push_back(tri);
          .      .    .           .          .     .           .      .    .      }
          .      .    .           .          .     .           .      .    .    }
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .    // the lists must be sorted
          .      .    .           .          .     .           .      .    .    matchlisttype::iterator iter;
          4      0    0           2          2     0           .      .    .    for(iter=matchlist->begin(); iter!= matchlist->end(); iter++){
          .      .    .           .          .     .           .      .    .      sort(iter->second.begin(), iter->second.end());
          .      .    .           .          .     .           .      .    .    }
          .      .    .           .          .     .           .      .    .    return matchlist;
          7      0    0           5          1     1           .      .    .  }
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  #ifdef ALIGN_OUTPUT
          .      .    .           .          .     .           .      .    .  static PyObject *
          .      .    .           .          .     .           .      .    .  align_draw(PyObject *self, PyObject *args)
          .      .    .           .          .     .           .      .    .  { 
          .      .    .           .          .     .           .      .    .    char* file;
-- line 261 ----------------------------------------
-- line 399 ----------------------------------------
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .      self->ob_type->tp_free((PyObject*)self);
          .      .    .           .          .     .           .      .    .  }
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  extern "C" int
          .      .    .           .          .     .           .      .    .  alignment_init(align_AlignmentObject *self, PyObject *args, PyObject *kwds)
          8      1    1           1          0     0           4      0    0  {
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .      double secs;
          3      1    1           .          .     .           3      0    0      PyObject  *x_name=NULL,*y_name=NULL,*output=NULL;
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .      static char *kwlist[] = {"x_name","y_name","secs_to_align","output", NULL};
          .      .    .           .          .     .           .      .    .  
         20      2    1           2          0     0           9      0    0      if (! PyArg_ParseTupleAndKeywords(args, kwds, "|SSdS", kwlist,
          .      .    .           .          .     .           .      .    .  				      &x_name,&y_name,&secs,&output))
          .      .    .           .          .     .           .      .    .          return -1; 
          .      .    .           .          .     .           .      .    .  
          4      1    0           2          0     0           2      0    0      self->secs_to_align = secs;
          .      .    .           .          .     .           .      .    .  
          3      0    0           1          0     0           .      .    .      if (x_name) {
          8      1    1           2          0     0           1      0    0          Py_XDECREF(self->x_name);
          1      0    0           1          0     0           .      .    .          Py_INCREF(x_name);
          2      0    0           1          0     0           1      0    0          self->x_name = (PyStringObject*)x_name;
          .      .    .           .          .     .           .      .    .      }
          .      .    .           .          .     .           .      .    .  
          3      0    0           1          0     0           .      .    .      if (y_name) {
          8      1    0           2          0     0           1      0    0          Py_XDECREF(self->y_name);
          1      0    0           1          0     0           .      .    .          Py_INCREF(y_name);
          2      0    0           1          0     0           1      0    0          self->y_name = (PyStringObject*)y_name;
          .      .    .           .          .     .           .      .    .      }
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          3      0    0           1          0     0           .      .    .      if (output) {
          .      .    .           .          .     .           .      .    .          Py_XDECREF(self->output);
          .      .    .           .          .     .           .      .    .          Py_INCREF(output);
          .      .    .           .          .     .           .      .    .          self->output = (PyStringObject*)output;
          .      .    .           .          .     .           .      .    .      }
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .      
          .      .    .           .          .     .           .      .    .  
          1      1    1           .          .     .           1      0    0      self->num_of_align=10;
          2      1    0           .          .     .           2      0    0      self->nu=1.0;
          2      0    0           .          .     .           2      0    0      self->mu=1.0;
          2      0    0           .          .     .           2      0    0      self->lambda=0.5;
          2      1    1           .          .     .           2      0    0      self->xi=1.0;
          1      0    0           .          .     .           .      .    .      return 0;
          6      0    0           4          0     0           .      .    .  }
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  static 
          .      .    .           .          .     .           .      .    .  PyObject *
          .      .    .           .          .     .           .      .    .  alignment_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
          9      2    1           1          0     0           5      0    0  {
          .      .    .           .          .     .           .      .    .      align_AlignmentObject *self;
          .      .    .           .          .     .           .      .    .  
          4      1    1           1          1     1           3      0    0      self = (align_AlignmentObject *)type->tp_alloc(type, 0);
          2      0    0           .          .     .           .      .    .      if (self != NULL) {
          2      0    0           .          .     .           2      0    0        self->secs_to_align = 0.0;
          2      1    0           .          .     .           2      0    0        self->nu=0.0;
          4      0    0           .          .     .           3      0    0        self->x_name = (PyStringObject*)PyString_FromString("");
          2      0    0           .          .     .           .      .    .        if (self->x_name == NULL)
          .      .    .           .          .     .           .      .    .  	{
          .      .    .           .          .     .           .      .    .  	  Py_DECREF(self);
          .      .    .           .          .     .           .      .    .  	  return NULL;
          .      .    .           .          .     .           .      .    .  	}
          3      1    1           .          .     .           3      0    0        self->y_name = (PyStringObject*)PyString_FromString("");
          2      0    0           .          .     .           .      .    .        if (self->y_name == NULL)
          .      .    .           .          .     .           .      .    .  	{
          .      .    .           .          .     .           .      .    .  	  Py_DECREF(self);
          .      .    .           .          .     .           .      .    .  	  return NULL;
          .      .    .           .          .     .           .      .    .  	}
          3      0    0           .          .     .           3      0    0        self->output = (PyStringObject*)PyString_FromString("");
          2      0    0           .          .     .           .      .    .        if (self->output == NULL)
          .      .    .           .          .     .           .      .    .  	{
          .      .    .           .          .     .           .      .    .  	  Py_DECREF(self);
          .      .    .           .          .     .           .      .    .  	  return NULL;
          .      .    .           .          .     .           .      .    .  	}
          .      .    .           .          .     .           .      .    .          
          3      1    1           .          .     .           3      0    0        self->bestAlignments=PyList_New(0);
          2      0    0           .          .     .           .      .    .        if (self->bestAlignments == NULL)
          .      .    .           .          .     .           .      .    .  	{
          .      .    .           .          .     .           .      .    .  	  Py_DECREF(self);
          .      .    .           .          .     .           .      .    .  	  return NULL;
          .      .    .           .          .     .           .      .    .  	}
          .      .    .           .          .     .           .      .    .  
         15      2    0           4          0     0           7      0    0        self->CP=new struct __CPSTUF;
          3      0    0           .          .     .           .      .    .        if (self->CP==NULL) {
          .      .    .           .          .     .           .      .    .  	return NULL;
          .      .    .           .          .     .           .      .    .        }
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .      }
          .      .    .           .          .     .           .      .    .  
          1      0    0           .          .     .           1      0    0      self->item_count=0;
          6      1    1           2          0     0           4      0    0      alignment_init(self,args,kwds);
          .      .    .           .          .     .           .      .    .  
          2      0    0           .          .     .           .      .    .      return (PyObject *)self;
          6      1    0           5          0     0           .      .    .  }
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  static PyObject*
          .      .    .           .          .     .           .      .    .  alignment_nextBest(align_AlignmentObject *self)
         24      4    4           .          .     .          15      0    0  {
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .    // backtracing
          6      0    0           .          .     .           6      0    0    int pos_x=0, pos_y=0;
          9      0    0           .          .     .           9      0    0    PyObject *ret=PyList_New(0);
          .      .    .           .          .     .           .      .    .  
          3      1    0           3          3     1           .      .    .    store max=-1.0;
          .      .    .           .          .     .           .      .    .    
     83,574      1    1      41,778          4     2          12      0    0    for (uint x=0; x< self->CP->matrix.size(); x++) {
  1,901,910      1    1     125,298      3,918 3,918      20,883      0    0      for(uint y=0; y<self->CP->matrix[x].size(); y++) {
          .      .    .           .          .     .           .      .    .        if (self->CP->matrix[x][y].value > max) {
          .      .    .           .          .     .           .      .    .  	max= self->CP->matrix[x][y].value;
        123      0    0           .          .     .         123      0    0  	pos_x=x;
  1,651,683      0    0           .          .     .         123      0    0  	pos_y=y;
          .      .    .           .          .     .           .      .    .        }
          .      .    .           .          .     .           .      .    .      }
          .      .    .           .          .     .           .      .    .    }
          .      .    .           .          .     .           .      .    .  
         18      1    1           3          3     3           .      .    .    if(max<0.0) {
          .      .    .           .          .     .           .      .    .      Py_DECREF(ret);
          .      .    .           .          .     .           .      .    .      Py_INCREF(Py_None);
          .      .    .           .          .     .           .      .    .      return Py_None;
          .      .    .           .          .     .           .      .    .    }
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .    //string ret;
         18      2    1           6          0     0           .      .    .    if (pos_x>=0 && pos_y>=0 && pos_x<(int)self->CP->matrix.size() && pos_y<(int)self->CP->matrix[pos_x].size()){
          .      .    .           .          .     .           .      .    .      //while (matrix[pos_x][pos_y].x || matrix[pos_x][pos_y].y)
        122      1    0          47         34     0           .      .    .      do {
          .      .    .           .          .     .           .      .    .        uint const real_y= self->CP->index[self->CP->seq_x[pos_x].ID][pos_y];
          .      .    .           .          .     .           .      .    .        
          .      .    .           .          .     .           .      .    .        // don't look at this position again
          .      .    .           .          .     .           .      .    .        if (self->CP->matrix[pos_x][pos_y].value >0.0) {
          .      .    .           .          .     .           .      .    .  	self->CP->matrix[pos_x][pos_y].value *= -1.0;
          .      .    .           .          .     .           .      .    .        }
          .      .    .           .          .     .           .      .    .        
          .      .    .           .          .     .           .      .    .  
-- line 538 ----------------------------------------
-- line 540 ----------------------------------------
          .      .    .           .          .     .           .      .    .        if(self->CP->seq_x[pos_x].strand!=self->CP->seq_y[real_y].strand)
          .      .    .           .          .     .           .      .    .  	printf("strand conflict %d%c %d%c\n",self->CP->seq_x[pos_x].ID,self->CP->seq_x[pos_x].strand,self->CP->seq_y[real_y].ID,self->CP->seq_y[real_y].strand);
          .      .    .           .          .     .           .      .    .  #endif
          .      .    .           .          .     .           .      .    .        PyObject *ret_item=Py_BuildValue("(iids(ii)(ii))",
          .      .    .           .          .     .           .      .    .  				       pos_x, real_y, (double)abs((double)self->CP->matrix[pos_x][pos_y].value), 
          .      .    .           .          .     .           .      .    .  				       self->CP->ID_to_TF[self->CP->seq_x[pos_x].ID/2].c_str(),
          .      .    .           .          .     .           .      .    .  				       (int)self->CP->seq_x[pos_x].pos, (int)self->CP->seq_x[pos_x].epos,
          .      .    .           .          .     .           .      .    .  				       (int)self->CP->seq_y[real_y].pos, (int)self->CP->seq_y[real_y].epos);
        200      1    1          50          0     0         150      0    0        PyList_Append(ret,ret_item);
        350      0    0          50          0     0          50      0    0        Py_XDECREF(ret_item);
          .      .    .           .          .     .           .      .    .  		  
          .      .    .           .          .     .           .      .    .  // 	  snprintf(result,255,"D[%d][%d]=%.2f %s (%d,%d) <=> (%d,%d)\n",
          .      .    .           .          .     .           .      .    .  // 		   pos_x, real_y, abs(self->CP->matrix[pos_x][pos_y].value), 
          .      .    .           .          .     .           .      .    .  // 		   self->CP->ID_to_TF[self->CP->seq_x[pos_x].ID].c_str(),
          .      .    .           .          .     .           .      .    .  // 		   (uint)self->CP->seq_x[pos_x].pos, (uint)self->CP->seq_x[pos_x].epos,
          .      .    .           .          .     .           .      .    .  // 		   (uint)self->CP->seq_y[real_y].pos, (uint)self->CP->seq_y[real_y].epos);
          .      .    .           .          .     .           .      .    .        
          .      .    .           .          .     .           .      .    .        //ret=result + ret;
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .        int new_pos_x= self->CP->matrix[pos_x][pos_y].x;
          .      .    .           .          .     .           .      .    .        pos_y= self->CP->matrix[pos_x][pos_y].y;
        100      0    0          50          0     0          50      0    0        pos_x= new_pos_x;
        194      0    0           .          .     .           .      .    .      } while (pos_x>=0 && pos_y>=0); 
          .      .    .           .          .     .           .      .    .    }
          .      .    .           .          .     .           .      .    .      
          6      0    0           3          0     0           .      .    .    return ret;
          .      .    .           .          .     .           .      .    .  
         18      0    0          15          0     0           .      .    .  }
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  static PyMethodDef alignment_methods[] = {
          .      .    .           .          .     .           .      .    .      {"nextBest", (PyCFunction)alignment_nextBest, METH_NOARGS,
          .      .    .           .          .     .           .      .    .       "Return the next best alignment from the matrix."
          .      .    .           .          .     .           .      .    .      },
          .      .    .           .          .     .           .      .    .      {NULL}  /* Sentinel */
-- line 575 ----------------------------------------
-- line 652 ----------------------------------------
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  //////////////////////////////////////////////////////////////////////
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  inline int indexYBeforeOrAtBp(int xx,struct __CPSTUF *CP, double const pos)
304,523,808     95   29           .          .     . 190,327,380      0    0  {
          .      .    .           .          .     .           .      .    .    // MUCH better version of indexBeforeOrAtBp
          .      .    .           .          .     .           .      .    .    // run for 1500x1370 matrix took 6.0 CPU seconds
          .      .    .           .          .     .           .      .    .    // for the old version the run took 132 CPU seconds
          .      .    .           .          .     .           .      .    .    int yy;
          .      .    .           .          .     .           .      .    .    vector<int> const &index=CP->index[CP->seq_x[xx].ID];
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .    assert(xx>=0 && xx<(int)CP->prevYindex.size());
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .    //printf("\n\nAsking for xx=%d  pos=%f (prevPos=%f)\n",xx,pos,CP->prevPos[xx]);
          .      .    .           .          .     .           .      .    .    if(CP->prevYindex[xx]<0 || pos < CP->prevPos[xx]) {  // Not going forward. Start from beginning.
          .      .    .           .          .     .           .      .    .      //printf("STARTING FROM BEGINNING\n");
  2,944,855      0    0           .          .     .           .      .    .      yy=0;
          .      .    .           .          .     .           .      .    .    } else {  // Going forward. Start where we left off.
          .      .    .           .          .     .           .      .    .      yy=CP->prevYindex[xx];
          .      .    .           .          .     .           .      .    .    }
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .    assert(yy>=0);
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .    //printf("Searching.. yy=%d < %d\n",yy,index.size());
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
 76,130,952      0    0  38,065,476 21,083,294     6           .      .    .    while(yy < (int)index.size() && CP->seq_y[index.at(yy)].epos <= pos) {
          .      .    .           .          .     .           .      .    .      //printf("Skipping in a loop.. yy=%d (epos=%f)\n",yy,CP->seq_y[index.at(yy)].epos);
143,823,472      0    0           .          .     .           .      .    .      yy++;
          .      .    .           .          .     .           .      .    .    }
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
 38,065,476      0    0           .          .     .           .      .    .    yy--; // We went too far. Let's go back.
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .    
          .      .    .           .          .     .           .      .    .    /*
          .      .    .           .          .     .           .      .    .    printf("xx=%d yy=%d < len(index)=%d\n",xx,yy, index.size());
          .      .    .           .          .     .           .      .    .    printf("epos=%f\n",
          .      .    .           .          .     .           .      .    .  	 ((yy>=0 && (yy)<(int)index.size())?CP->seq_y[index.at(yy)].epos:-1.0));
          .      .    .           .          .     .           .      .    .    printf("pos=%f\n",pos);
-- line 699 ----------------------------------------
-- line 719 ----------------------------------------
          .      .    .           .          .     .           .      .    .      next=CP->seq_y[index[yy+1]].epos;
          .      .    .           .          .     .           .      .    .    }
          .      .    .           .          .     .           .      .    .    if(yy>=0) {
          .      .    .           .          .     .           .      .    .      assert(prev<CP->seq_y[index[yy]].epos && CP->seq_y[index[yy]].epos<pos && CP->seq_y[index[yy]].epos<next);
          .      .    .           .          .     .           .      .    .    }
          .      .    .           .          .     .           .      .    .  #endif
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .    return yy;
266,458,332     56   27 190,327,380      4,369     0           .      .    .  }
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  static PyObject *
          .      .    .           .          .     .           .      .    .  alignObject(align_AlignmentObject *self)
          8      1    1           .          .     .           5      0    0  { 
          .      .    .           .          .     .           .      .    .   
          .      .    .           .          .     .           .      .    .    tms before,after;
          3      1    0           .          .     .           3      3    3    long ticks_per_sec=sysconf(_SC_CLK_TCK);
          .      .    .           .          .     .           .      .    .    long ticks_to_align;
          1      0    0           .          .     .           1      0    0    uint mem_usage=0;
          .      .    .           .          .     .           .      .    .    
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .    // Start timing
          3      0    0           .          .     .           2      0    0    times(&before);
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .    // building the index map
          .      .    .           .          .     .           .      .    .    self->CP->index.resize(self->CP->ID_to_TF.size()*2);
          .      .    .           .          .     .           .      .    .  
        882      1    1         586          0     0           3      1    1    for(uint id=0; id<self->CP->index.size(); id++){
  6,626,940      1    1         292          0     0         292      0    0      for(uint y=0; y<self->CP->seq_y.size(); y++) {
          .      .    .           .          .     .           .      .    .        if (id == self->CP->seq_y[y].ID){
          .      .    .           .          .     .           .      .    .  	self->CP->index[id].push_back(y);
     37,815      0    0      22,689      6,160     0       7,563      0    0  	mem_usage += sizeof(int);
          .      .    .           .          .     .           .      .    .        }
          .      .    .           .          .     .           .      .    .      }
          .      .    .           .          .     .           .      .    .    }
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .    // allocating the matrix
     13,922      0    0           .          .     .       6,961      0    0    for (uint i=0; i<self->CP->seq_x.size(); i++){
          .      .    .           .          .     .           .      .    .      self->CP->matrix.push_back(vector<matrixentry> (self->CP->index[self->CP->seq_x[i].ID].size()));
          .      .    .           .          .     .           .      .    .      self->item_count+=self->CP->index[self->CP->seq_x[i].ID].size();
          .      .    .           .          .     .           .      .    .      mem_usage += self->CP->index[self->CP->seq_x[i].ID].size()*sizeof(matrixentry);	
          .      .    .           .          .     .           .      .    .    }
          3      0    0           2          0     0           1      0    0    self->mem_usage=mem_usage;
          1      0    0           1          0     0           .      .    .    self->fill_factor=(self->item_count*1.0/(self->CP->seq_x.size() * self->CP->seq_y.size()));
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
         11      1    1           3          1     1           4      0    0    cout <<"Sequence length: x: "<<self->CP->seq_x.size()<<", y: "<<self->CP->seq_y.size()<<endl
          .      .    .           .          .     .           .      .    .         <<"used memory ~ "<< (mem_usage>>10)  <<" kilobytes"<<endl
          .      .    .           .          .     .           .      .    .         <<"normal matrix size would be ~ "
          .      .    .           .          .     .           .      .    .         << ((self->CP->seq_x.size() * self->CP->seq_y.size() * sizeof(matrixentry))>>10) <<" kilobytes"<<endl
          .      .    .           .          .     .           .      .    .      <<"So using only "<<(100.0*mem_usage)/(self->CP->seq_x.size() * self->CP->seq_y.size() * sizeof(matrixentry))<<" percent of the matrix"<<endl
          .      .    .           .          .     .           .      .    .         <<"Filling only "<<(self->fill_factor*100.0) <<" percent of the cells"<<endl;
          .      .    .           .          .     .           .      .    .    
          .      .    .           .          .     .           .      .    .        
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .    // filling the matrix using dynamic programming
          .      .    .           .          .     .           .      .    .    matrixentry entry;
          .      .    .           .          .     .           .      .    .    int x, y;
          .      .    .           .          .     .           .      .    .  
          2      1    1           .          .     .           1      1    0    int cells_filled=0;
          .      .    .           .          .     .           .      .    .    double help;
          .      .    .           .          .     .           .      .    .  
     20,888      1    1       6,963          2     0       6,963      0    0    for (x=0; x<(int)self->CP->seq_x.size(); x++) {
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .      cells_filled+=1+self->CP->matrix[x].size();
     34,523      0    0       6,867          0     0       6,867      0    0      if(cells_filled>OUTPUTFREQ) {
          .      .    .           .          .     .           .      .    .        cout<< "filling line "<<x+1<<" of "<<self->CP->seq_x.size() << " of length "<<self->CP->matrix[x].size()<<endl;
        376      0    0         188         94     0          94      0    0        cells_filled-=OUTPUTFREQ;
          .      .    .           .          .     .           .      .    .      }
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
  1,941,084     96   59     825,780         40     0     282,221      0    0      for(y=0; y<(int)self->CP->matrix[x].size(); y++){
          .      .    .           .          .     .           .      .    .        int const real_y= self->CP->index[self->CP->seq_x[x].ID][y];
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .        entry.value= (store)self->lambda*(self->CP->seq_x[x].weight + self->CP->seq_y[real_y].weight);
  1,651,560      0    0     275,260         95     0           .      .    .        if(entry.value<0.0) entry.value=0.0;
    275,260      0    0           .          .     .     275,260      0    0        entry.x=-1;
    275,260      0    0           .          .     .     275,260      0    0        entry.y=-1;
          .      .    .           .          .     .           .      .    .        //if(x>250) cout<<x<<","<<y<<endl;
    825,780      1    1     275,260          0     0     275,260      0    0        int xx=x-1;
  4,599,883      2    0   1,441,541          0     0           .      .    .        while(xx>=0 && self->CP->seq_x[x].pos<(self->CP->seq_x[xx].epos+0.5)) {
  2,122,372      0    0     615,761          0     0           .      .    .  	xx--;
          .      .    .           .          .     .           .      .    .  	
          .      .    .           .          .     .           .      .    .        }
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .        //printf("x,y=%d,%d (val=%g=%g*(%g+%g))\n",x,real_y,entry.value,self->lambda,self->CP->seq_x[x].weight,self->CP->seq_y[real_y].weight);
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .        int real_yy;
          .      .    .           .          .     .           .      .    .        double delta_x,delta_y;
381,723,957    193   40 229,218,636         93     0   1,101,040      0    0        for(; 
          .      .    .           .          .     .           .      .    .  	  xx>=0 && 
          .      .    .           .          .     .           .      .    .  	    (delta_x=(self->CP->seq_x[x].pos-self->CP->seq_x[xx].epos-1.0))<MAX_BP_DIST; 
          .      .    .           .          .     .           .      .    .  	  xx--){
          .      .    .           .          .     .           .      .    .  #ifdef HEAVY_DEBUG
          .      .    .           .          .     .           .      .    .  	assert(indexBeforeOrAtBp(self->CP->index[self->CP->seq_x[xx].ID],self->CP->seq_y,self->CP->seq_y[real_y].pos-0.5) ==
          .      .    .           .          .     .           .      .    .  	       indexYBeforeOrAtBp(xx,self->CP,self->CP->seq_y[real_y].pos-0.5));
          .      .    .           .          .     .           .      .    .  #endif
          .      .    .           .          .     .           .      .    .  	//for (int yy=indexBeforeOrAtBp(self->CP->index[self->CP->seq_x[xx].ID],self->CP->seq_y,self->CP->seq_y[real_y].pos-0.5);
450,790,658      2    1 106,896,735     65,725     1  38,065,476 10,674    3  	for (int yy=indexYBeforeOrAtBp(xx,self->CP,self->CP->seq_y[real_y].pos-0.5);
          .      .    .           .          .     .           .      .    .  	     yy>=0 && 
          .      .    .           .          .     .           .      .    .  	       (delta_y=(self->CP->seq_y[real_y].pos - self->CP->seq_y[(real_yy=self->CP->index[self->CP->seq_x[xx].ID][yy])].epos-1.0))<MAX_BP_DIST; 
          .      .    .           .          .     .           .      .    .  	     yy--){
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  	  assert(delta_x>-0.5);
          .      .    .           .          .     .           .      .    .  	  assert(delta_y>-0.5);
          .      .    .           .          .     .           .      .    .  	  assert(xx<x);
          .      .    .           .          .     .           .      .    .  	  //if(delta_y<0.5)
-- line 825 ----------------------------------------
-- line 844 ----------------------------------------
          .      .    .           .          .     .           .      .    .  	    self->lambda *(self->CP->seq_x[x].weight + self->CP->seq_y[real_y].weight) -
          .      .    .           .          .     .           .      .    .  	    self->mu *(delta_x + delta_y)/2.0-
          .      .    .           .          .     .           .      .    .  	    self->nu * (delta_x-delta_y)*(delta_x-delta_y)/(delta_x+delta_y)-
          .      .    .           .          .     .           .      .    .  	    self->xi *anglepenalty(delta_x,delta_y,self->nuc_per_rotation);
          .      .    .           .          .     .           .      .    .  	  */
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  	  // Be carefull for correctness and speed!!!
          .      .    .           .          .     .           .      .    .  	  //if(delta_x==0.0 && delta_y==0.0) {  // Security check for division by zero
276,934,507     95   11  61,540,058         92     0           .      .    .  	  if((delta_x+delta_y)==0.0) {
          .      .    .           .          .     .           .      .    .  	    help=(double)self->CP->matrix[xx][yy].value +
          .      .    .           .          .     .           .      .    .  	      self->lambda *(self->CP->seq_x[x].weight + self->CP->seq_y[real_y].weight) -
          .      .    .           .          .     .           .      .    .  	      self->mu *(delta_x + delta_y)/2.0;
          .      .    .           .          .     .           .      .    .  	  } else {
          .      .    .           .          .     .           .      .    .  	    help=(double)self->CP->matrix[xx][yy].value +
          .      .    .           .          .     .           .      .    .  	      self->lambda *(self->CP->seq_x[x].weight + self->CP->seq_y[real_y].weight) -
          .      .    .           .          .     .           .      .    .  	      self->mu *(delta_x + delta_y)/2.0 -
          .      .    .           .          .     .           .      .    .  	      self->nu * (delta_x-delta_y)*(delta_x-delta_y)/(delta_x+delta_y)-
-- line 860 ----------------------------------------
-- line 864 ----------------------------------------
          .      .    .           .          .     .           .      .    .  	  assert(finite(help));
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  	    //xi *squaremod((delta_x - delta_y) * 2.0 * PI/nuc_per_rotation) / 
          .      .    .           .          .     .           .      .    .  	    //(delta_x + delta_y);
          .      .    .           .          .     .           .      .    .  	  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  	  //if(help>entry.value && xx!=x && yy!=y){
          .      .    .           .          .     .           .      .    .  	  //if(help>entry.value && xx<x && real_yy<real_y){
215,390,203      1    1  30,770,029    238,474     0           .      .    .  	  if(help>entry.value){
    139,678      0    0           .          .     .     139,678      0    0  	    entry.value= (store)help;
 61,819,414      0    0     139,678          0     0     139,678      0    0  	    entry.x=xx;
    139,678      0    0           .          .     .     139,678      0    0  	    entry.y=yy;
          .      .    .           .          .     .           .      .    .  	  }
          .      .    .           .          .     .           .      .    .  	}
          .      .    .           .          .     .           .      .    .        }
          .      .    .           .          .     .           .      .    .        
          .      .    .           .          .     .           .      .    .        self->CP->matrix[x][y]= entry;
          .      .    .           .          .     .           .      .    .      }
          .      .    .           .          .     .           .      .    .    }
          .      .    .           .          .     .           .      .    .    
-- line 883 ----------------------------------------
-- line 940 ----------------------------------------
          .      .    .           .          .     .           .      .    .      
          .      .    .           .          .     .           .      .    .      alignment.append(ret);
          .      .    .           .          .     .           .      .    .    }
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .    */
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .    // End timing
          3      1    0           .          .     .           2      0    0    times(&after);
          .      .    .           .          .     .           .      .    .  
          7      1    0           4          0     0           .      .    .    ticks_to_align=((after.tms_utime-before.tms_utime)+
          .      .    .           .          .     .           .      .    .  		 (after.tms_stime-before.tms_stime));
          7      0    0           3          1     1           2      0    0    self->secs_to_align=((double)ticks_to_align)/ticks_per_sec;
          .      .    .           .          .     .           .      .    .    
          .      .    .           .          .     .           .      .    .    //snprintf(result,255,"### Alignment took %.1f CPU seconds.\n",self->secs_to_align);
          .      .    .           .          .     .           .      .    .    //alignment.append(string(result));
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .    
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          6      1    1           2          1     1           1      0    0    Py_DECREF(self->output);
          7      1    0           1          0     0           4      0    0    self->output=(PyStringObject*)Py_BuildValue("s","No output. Use nextBest()");
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .    return (PyObject*)self;
          7      0    0           6          0     0           .      .    .  }
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  static PyObject *
          .      .    .           .          .     .           .      .    .  align_alignCommon(PyObject *self, PyObject *args,istream *data)
          8      2    2           .          .     .           5      0    0  {
          .      .    .           .          .     .           .      .    .    char* stub;
          .      .    .           .          .     .           .      .    .    int num_of_align;
          .      .    .           .          .     .           .      .    .    double lambda, xi, mu, nuc_per_rotation,nu;
          .      .    .           .          .     .           .      .    .    string firstSeqName,secondSeqName;
          .      .    .           .          .     .           .      .    .  
         21      3    2           1          0     0          10      0    0    if (!PyArg_ParseTuple(args, "siddddd", &stub, &num_of_align, 
          .      .    .           .          .     .           .      .    .  			&lambda, &xi, &mu, &nu,&nuc_per_rotation)){
          .      .    .           .          .     .           .      .    .      return  Py_BuildValue("s", "");
          .      .    .           .          .     .           .      .    .    }
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          4      2    2           1          0     0           3      1    1    matchlisttype* matchlist=parseStream(data);
          .      .    .           .          .     .           .      .    .    matchlisttype::iterator iter;
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .    if(matchlist->size()<2)
          .      .    .           .          .     .           .      .    .      {
          .      .    .           .          .     .           .      .    .        #ifdef ALIGN_OUTPUT
          .      .    .           .          .     .           .      .    .        cerr<<"Error: too few sequences in data"<<endl;
          .      .    .           .          .     .           .      .    .        #endif
          .      .    .           .          .     .           .      .    .        return Py_BuildValue("s", "");
-- line 992 ----------------------------------------
-- line 1074 ----------------------------------------
          .      .    .           .          .     .           .      .    .      tmp_seq=seq_y;
          .      .    .           .          .     .           .      .    .      seq_y=seq_x;
          .      .    .           .          .     .           .      .    .      seq_x=tmp_seq;
          .      .    .           .          .     .           .      .    .  #endif
          .      .    .           .          .     .           .      .    .    }      
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .    //vector<id_triple> id_seq_x, id_seq_y;
          .      .    .           .          .     .           .      .    .    map<string, uint> TF_to_ID;
          2      0    0           .          .     .           1      1    1    uint id_counter=0;
     13,924      1    1       6,961         33     0           1      0    0    for(uint i=0; i< seq_x.size(); i++){
          .      .    .           .          .     .           .      .    .      if (TF_to_ID.find(seq_x[i].TF) == TF_to_ID.end()){
          .      .    .           .          .     .           .      .    .        TF_to_ID[seq_x[i].TF]=id_counter;
        438      1    0           .          .     .         146      0    0        id_counter++;
          .      .    .           .          .     .           .      .    .      }
          .      .    .           .          .     .           .      .    .    }
     15,126      0    0           .          .     .           .      .    .    for(uint i=0; i< seq_y.size(); i++){
          .      .    .           .          .     .           .      .    .      if (TF_to_ID.find(seq_y[i].TF) == TF_to_ID.end()){
          .      .    .           .          .     .           .      .    .        TF_to_ID[seq_y[i].TF]=id_counter;
          .      .    .           .          .     .           .      .    .        id_counter++;
          .      .    .           .          .     .           .      .    .      }
          .      .    .           .          .     .           .      .    .    }
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .    PyObject *retargs=Py_BuildValue("(ss)",firstSeqName.c_str(),secondSeqName.c_str());
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          6      1    0           .          .     .           5      1    0    align_AlignmentObject *ret_self=(align_AlignmentObject *)alignment_new(&align_AlignmentType,retargs,NULL);
          5      1    1           1          0     0           1      0    0    Py_DECREF(retargs);
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .    ret_self->CP->ID_to_TF.resize(TF_to_ID.size());
          .      .    .           .          .     .           .      .    .    //  vector<string> ID_to_TF(TF_to_ID.size());
          .      .    .           .          .     .           .      .    .    for(map<string, uint>::iterator i=TF_to_ID.begin();i!= TF_to_ID.end(); i++){
          .      .    .           .          .     .           .      .    .      ret_self->CP->ID_to_TF[i->second]=i->first;
          .      .    .           .          .     .           .      .    .    }
          .      .    .           .          .     .           .      .    .  
     32,764      0    0           .          .     .      32,764      0    0    id_triple idtr;
     13,924      1    0       6,961          4     0           1      0    0    for(uint i=0; i< seq_x.size(); i++){
          .      .    .           .          .     .           .      .    .      idtr.ID=TF_to_ID[seq_x[i].TF];
          .      .    .           .          .     .           .      .    .      if(seq_x[i].strand=='+') {
      7,082      1    1           .          .     .           .      .    .        idtr.ID=idtr.ID*2;
          .      .    .           .          .     .           .      .    .      } else {
     10,381      0    0           .          .     .       6,961      0    0        idtr.ID=idtr.ID*2+1;
          .      .    .           .          .     .           .      .    .      }
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .      idtr.pos=(double)seq_x[i].pos;
          .      .    .           .          .     .           .      .    .      idtr.epos=(double)seq_x[i].epos;
          .      .    .           .          .     .           .      .    .      idtr.weight=seq_x[i].weight;
          .      .    .           .          .     .           .      .    .      idtr.strand=seq_x[i].strand;
          .      .    .           .          .     .           .      .    .      //id_seq_x.push_back(idtr);
          .      .    .           .          .     .           .      .    .      ret_self->CP->seq_x.push_back(idtr);
          .      .    .           .          .     .           .      .    .      ret_self->CP->prevYindex.push_back(0);
          .      .    .           .          .     .           .      .    .      ret_self->CP->prevPos.push_back(-1.0);
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .    }
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .    
     15,126      1    1       7,563          6     0           .      .    .    for(uint i=0; i< seq_y.size(); i++){
          .      .    .           .          .     .           .      .    .      idtr.ID=TF_to_ID[seq_y[i].TF];
          .      .    .           .          .     .           .      .    .      if(seq_y[i].strand=='+') {
      7,786      1    1           .          .     .           .      .    .        idtr.ID=idtr.ID*2;
          .      .    .           .          .     .           .      .    .      } else {
     11,233      0    0           .          .     .       7,563      0    0        idtr.ID=idtr.ID*2+1;
          .      .    .           .          .     .           .      .    .      }
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .      idtr.pos=(double)seq_y[i].pos;
          .      .    .           .          .     .           .      .    .      idtr.epos=(double)seq_y[i].epos;
          .      .    .           .          .     .           .      .    .      idtr.weight=seq_y[i].weight;
          .      .    .           .          .     .           .      .    .      idtr.strand=seq_y[i].strand;
          .      .    .           .          .     .           .      .    .      //id_seq_y.push_back(idtr);
          .      .    .           .          .     .           .      .    .      ret_self->CP->seq_y.push_back(idtr);
          .      .    .           .          .     .           .      .    .    }
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          5      1    1           3          1     1           2      1    1    ret_self->lambda=lambda;
          4      0    0           2          1     1           2      0    0    ret_self->xi=xi;
          4      0    0           2          0     0           2      0    0    ret_self->mu=mu;
          4      2    1           2          0     0           2      0    0    ret_self->nu=nu;
          4      0    0           2          0     0           2      0    0    ret_self->nuc_per_rotation=nuc_per_rotation;
          2      0    0           1          0     0           1      0    0    ret_self->num_of_align=num_of_align;
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          3      2    1           .          .     .           3      1    1    return (PyObject*)alignObject(ret_self);
          .      .    .           .          .     .           .      .    .    //id_seq_x, id_seq_y, ID_to_TF, 
          .      .    .           .          .     .           .      .    .    //	       num_of_align, lambda, xi, mu, nuc_per_rotation,firstSeqName,secondSeqName);
          6      1    1           5          0     0           .      .    .  }
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  static PyObject *
          .      .    .           .          .     .           .      .    .  align_alignfile(PyObject *self, PyObject *args)
          9      2    1           1          0     0           5      0    0  {
          .      .    .           .          .     .           .      .    .    char* file;
          .      .    .           .          .     .           .      .    .    int num_of_align;
          .      .    .           .          .     .           .      .    .    double lambda, xi, mu, nuc_per_rotation,nu;
          .      .    .           .          .     .           .      .    .    PyObject *ret;
          .      .    .           .          .     .           .      .    .    string firstSeqName,secondSeqName;
          .      .    .           .          .     .           .      .    .  
         20      3    1           .          .     .          10      1    0    if (!PyArg_ParseTuple(args, "siddddd", &file, &num_of_align, 
          .      .    .           .          .     .           .      .    .  			&lambda, &xi, &mu, &nu,&nuc_per_rotation)){
          .      .    .           .          .     .           .      .    .      return  Py_BuildValue("s", "");
          .      .    .           .          .     .           .      .    .    }
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .    ifstream inData(file);
          .      .    .           .          .     .           .      .    .  
          6      2    1           1          1     0           4      0    0    ret=align_alignCommon(self,args,&inData);
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .    inData.close();
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .    return ret;
          .      .    .           .          .     .           .      .    .  }
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  static PyObject *
-- line 1196 ----------------------------------------
-- line 1233 ----------------------------------------
          .      .    .           .          .     .           .      .    .    {NULL, NULL, 0, NULL}        /* Sentinel */
          .      .    .           .          .     .           .      .    .  };
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  //PyMODINIT_FUNC
          .      .    .           .          .     .           .      .    .  extern "C"
          .      .    .           .          .     .           .      .    .  void
          .      .    .           .          .     .           .      .    .  initalign(void)
          7      2    2           .          .     .           4      0    0  {
          .      .    .           .          .     .           .      .    .      PyObject* m=NULL;
          .      .    .           .          .     .           .      .    .  
          2      0    0           1          0     0           1      1    0      align_AlignmentType.tp_new = PyType_GenericNew;
          5      2    0           .          .     .           2      0    0      if (PyType_Ready(&align_AlignmentType) < 0)
          .      .    .           .          .     .           .      .    .        return;
          .      .    .           .          .     .           .      .    .      
          8      1    1           .          .     .           6      0    0      m=Py_InitModule("align", alignMethods);
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .      
          2      0    0           .          .     .           .      .    .      if(m==NULL)
          .      .    .           .          .     .           .      .    .        return;
          .      .    .           .          .     .           .      .    .  
          1      0    0           1          0     0           .      .    .      Py_INCREF(&align_AlignmentType);
          5      1    0           .          .     .           4      0    0      PyModule_AddObject(m, "Alignment", (PyObject *)&align_AlignmentType);
          5      0    0           4          1     0           .      .    .  }
          .      .    .           .          .     .           .      .    .  
          .      .    .           .          .     .           .      .    .  

--------------------------------------------------------------------------------
-- User-annotated source: /usr/include/c++/3.2.2/bits/ + stl_vector.h
--------------------------------------------------------------------------------
           Ir I1mr I2mr            Dr        D1mr    D2mr          Dw    D1mw   D2mw 

-- line 104 ----------------------------------------
            .    .    .             .           .       .           .       .      .  class _Vector_alloc_base<_Tp, _Allocator, true> {
            .    .    .             .           .       .           .       .      .  public:
            .    .    .             .           .       .           .       .      .    typedef typename _Alloc_traits<_Tp, _Allocator>::allocator_type
            .    .    .             .           .       .           .       .      .            allocator_type;
            .    .    .             .           .       .           .       .      .    allocator_type get_allocator() const { return allocator_type(); }
            .    .    .             .           .       .           .       .      .  
            .    .    .             .           .       .           .       .      .    _Vector_alloc_base(const allocator_type&)
            .    .    .             .           .       .           .       .      .      : _M_start(0), _M_finish(0), _M_end_of_storage(0)
       67,274   12    6             .           .       .      67,266   3,339  2,844    {}
            .    .    .             .           .       .           .       .      .  
            .    .    .             .           .       .           .       .      .  protected:
            .    .    .             .           .       .           .       .      .    _Tp* _M_start;
            .    .    .             .           .       .           .       .      .    _Tp* _M_finish;
            .    .    .             .           .       .           .       .      .    _Tp* _M_end_of_storage;
            .    .    .             .           .       .           .       .      .  
            .    .    .             .           .       .           .       .      .    typedef typename _Alloc_traits<_Tp, _Allocator>::_Alloc_type _Alloc_type;
            .    .    .             .           .       .           .       .      .    _Tp* _M_allocate(size_t __n)
       37,211    1    0         6,961           5       3      30,250       4      0      { return _Alloc_type::allocate(__n); }
            .    .    .             .           .       .           .       .      .    void _M_deallocate(_Tp* __p, size_t __n)
       92,981   17    6        47,962         600     412      20,902       0      0      { _Alloc_type::deallocate(__p, __n);}
            .    .    .             .           .       .           .       .      .  };
            .    .    .             .           .       .           .       .      .  
            .    .    .             .           .       .           .       .      .  template <class _Tp, class _Alloc>
            .    .    .             .           .       .           .       .      .  struct _Vector_base
            .    .    .             .           .       .           .       .      .    : public _Vector_alloc_base<_Tp, _Alloc,
            .    .    .             .           .       .           .       .      .                                _Alloc_traits<_Tp, _Alloc>::_S_instanceless>
            .    .    .             .           .       .           .       .      .  {
            .    .    .             .           .       .           .       .      .    typedef _Vector_alloc_base<_Tp, _Alloc,
            .    .    .             .           .       .           .       .      .                               _Alloc_traits<_Tp, _Alloc>::_S_instanceless>
            .    .    .             .           .       .           .       .      .            _Base;
            .    .    .             .           .       .           .       .      .    typedef typename _Base::allocator_type allocator_type;
            .    .    .             .           .       .           .       .      .  
            .    .    .             .           .       .           .       .      .    _Vector_base(const allocator_type& __a) : _Base(__a) {}
      151,540    6    4        30,308           0       0      75,770       0      0    _Vector_base(size_t __n, const allocator_type& __a) : _Base(__a) {
            .    .    .             .           .       .           .       .      .      _M_start = _M_allocate(__n);
       22,701    1    0           292           0       0      22,409       1      0      _M_finish = _M_start;
      165,112    4    0        76,062           0       0      22,409       0      0      _M_end_of_storage = _M_start + __n;
            .    .    .             .           .       .           .       .      .    }
            .    .    .             .           .       .           .       .      .  
            .    .    .             .           .       .           .       .      .    ~_Vector_base() { _M_deallocate(_M_start, _M_end_of_storage - _M_start); }
            .    .    .             .           .       .           .       .      .  };
            .    .    .             .           .       .           .       .      .  
            .    .    .             .           .       .           .       .      .  
            .    .    .             .           .       .           .       .      .  /**
            .    .    .             .           .       .           .       .      .   *  @brief  A standard container which offers fixed time access to individual
-- line 148 ----------------------------------------
-- line 207 ----------------------------------------
            .    .    .             .           .       .           .       .      .    */
            .    .    .             .           .       .           .       .      .    iterator begin() { return iterator (_M_start); }
            .    .    .             .           .       .           .       .      .  
            .    .    .             .           .       .           .       .      .    /**
            .    .    .             .           .       .           .       .      .     *  Returns a read-only (constant) iterator that points to the first element
            .    .    .             .           .       .           .       .      .     *  in the vector.  Iteration is done in ordinary element order.
            .    .    .             .           .       .           .       .      .    */
            .    .    .             .           .       .           .       .      .    const_iterator begin() const
           14    2    2             2           0       0          12       2      2      { return const_iterator (_M_start); }
            .    .    .             .           .       .           .       .      .  
            .    .    .             .           .       .           .       .      .    /**
            .    .    .             .           .       .           .       .      .     *  Returns a read/write iterator that points one past the last element in
            .    .    .             .           .       .           .       .      .     *  the vector.  Iteration is done in ordinary element order.
            .    .    .             .           .       .           .       .      .    */
       10,560   33    3           112           0       0       7,012   2,651      0    iterator end() { return iterator (_M_finish); }
            .    .    .             .           .       .           .       .      .  
            .    .    .             .           .       .           .       .      .    /**
            .    .    .             .           .       .           .       .      .     *  Returns a read-only (constant) iterator that points one past the last
            .    .    .             .           .       .           .       .      .     *  element in the vector.  Iteration is done in ordinary element order.
            .    .    .             .           .       .           .       .      .    */
            .    .    .             .           .       .           .       .      .    const_iterator end() const { return const_iterator (_M_finish); }
            .    .    .             .           .       .           .       .      .  
            .    .    .             .           .       .           .       .      .    /**
-- line 229 ----------------------------------------
-- line 253 ----------------------------------------
            .    .    .             .           .       .           .       .      .     *  before the first element in the vector.  Iteration is done in reverse
            .    .    .             .           .       .           .       .      .     *  element order.
            .    .    .             .           .       .           .       .      .    */
            .    .    .             .           .       .           .       .      .    const_reverse_iterator rend() const
            .    .    .             .           .       .           .       .      .      { return const_reverse_iterator(begin()); }
            .    .    .             .           .       .           .       .      .  
            .    .    .             .           .       .           .       .      .    /**  Returns the number of elements in the vector.  */
            .    .    .             .           .       .           .       .      .    size_type size() const
  444,115,216   15    6       373,806         100       0      74,843       1      1      { return size_type(end() - begin()); }
            .    .    .             .           .       .           .       .      .  
            .    .    .             .           .       .           .       .      .    /**  Returns the size of the largest possible vector.  */
            .    .    .             .           .       .           .       .      .    size_type max_size() const
            .    .    .             .           .       .           .       .      .      { return size_type(-1) / sizeof(_Tp); }
            .    .    .             .           .       .           .       .      .  
            .    .    .             .           .       .           .       .      .    /**
            .    .    .             .           .       .           .       .      .     *  Returns the amount of memory that has been alocated for the current
            .    .    .             .           .       .           .       .      .     *  elements (?).
            .    .    .             .           .       .           .       .      .    */
            .    .    .             .           .       .           .       .      .    size_type capacity() const
            4    0    0             2           0       0           .       .      .      { return size_type(const_iterator(_M_end_of_storage) - begin()); }
            .    .    .             .           .       .           .       .      .  
            .    .    .             .           .       .           .       .      .    /**
            .    .    .             .           .       .           .       .      .     *  Returns true if the vector is empty.  (Thus begin() would equal end().)
            .    .    .             .           .       .           .       .      .    */
            .    .    .             .           .       .           .       .      .    bool empty() const
            .    .    .             .           .       .           .       .      .      { return begin() == end(); }
            .    .    .             .           .       .           .       .      .  
            .    .    .             .           .       .           .       .      .    /**
-- line 280 ----------------------------------------
-- line 281 ----------------------------------------
            .    .    .             .           .       .           .       .      .     *  @brief  Subscript access to the data contained in the vector.
            .    .    .             .           .       .           .       .      .     *  @param  n  The element for which data should be accessed.
            .    .    .             .           .       .           .       .      .     *  @return  Read/write reference to data.
            .    .    .             .           .       .           .       .      .     *
            .    .    .             .           .       .           .       .      .     *  This operator allows for easy, array-style, data access.
            .    .    .             .           .       .           .       .      .     *  Note that data access with this operator is unchecked and out_of_range
            .    .    .             .           .       .           .       .      .     *  lookups are not defined. (For checked lookups see at().)
            .    .    .             .           .       .           .       .      .    */
3,606,189,870  433  130 1,506,822,997 143,748,593 288,834 268,518,239 600,890 70,198    reference operator[](size_type __n) { return *(begin() + __n); }
            .    .    .             .           .       .           .       .      .  
            .    .    .             .           .       .           .       .      .    /**
            .    .    .             .           .       .           .       .      .     *  @brief  Subscript access to the data contained in the vector.
            .    .    .             .           .       .           .       .      .     *  @param  n  The element for which data should be accessed.
            .    .    .             .           .       .           .       .      .     *  @return  Read-only (constant) reference to data.
            .    .    .             .           .       .           .       .      .     *
            .    .    .             .           .       .           .       .      .     *  This operator allows for easy, array-style, data access.
            .    .    .             .           .       .           .       .      .     *  Note that data access with this operator is unchecked and out_of_range
-- line 297 ----------------------------------------
-- line 321 ----------------------------------------
            .    .    .             .           .       .           .       .      .     *  @param  n  The element for which data should be accessed.
            .    .    .             .           .       .           .       .      .     *  @return  Read-only (constant) reference to data.
            .    .    .             .           .       .           .       .      .     *
            .    .    .             .           .       .           .       .      .     *  This function provides for safer data access.  The parameter is first
            .    .    .             .           .       .           .       .      .     *  checked that it is in the range of the vector.  The function throws
            .    .    .             .           .       .           .       .      .     *  out_of_range if the check fails.
            .    .    .             .           .       .           .       .      .    */
            .    .    .             .           .       .           .       .      .    const_reference at(size_type __n) const
  108,606,332    0    0   108,606,332  36,892,945     932           .       .      .      { _M_range_check(__n); return (*this)[__n]; }
            .    .    .             .           .       .           .       .      .  
            .    .    .             .           .       .           .       .      .  
            .    .    .             .           .       .           .       .      .    explicit vector(const allocator_type& __a = allocator_type())
           12    1    1             .           .       .           3       0      0      : _Base(__a) {}
            .    .    .             .           .       .           .       .      .  
            .    .    .             .           .       .           .       .      .    vector(size_type __n, const _Tp& __value,
            .    .    .             .           .       .           .       .      .           const allocator_type& __a = allocator_type())
            .    .    .             .           .       .           .       .      .      : _Base(__n, __a)
            .    .    .             .           .       .           .       .      .      { _M_finish = uninitialized_fill_n(_M_start, __n, __value); }
            .    .    .             .           .       .           .       .      .  
            .    .    .             .           .       .           .       .      .    explicit vector(size_type __n)
       13,922    1    1             .           .       .       6,961       0      0      : _Base(__n, allocator_type())
            .    .    .             .           .       .           .       .      .      { _M_finish = uninitialized_fill_n(_M_start, __n, _Tp()); }
            .    .    .             .           .       .           .       .      .  
            .    .    .             .           .       .           .       .      .    vector(const vector<_Tp, _Alloc>& __x)
           12    2    0             2           0       0           .       .      .      : _Base(__x.size(), __x.get_allocator())
            .    .    .             .           .       .           .       .      .      { _M_finish = uninitialized_copy(__x.begin(), __x.end(), _M_start); }
            .    .    .             .           .       .           .       .      .  
            .    .    .             .           .       .           .       .      .    // Check whether it's an integral type.  If so, it's not an iterator.
            .    .    .             .           .       .           .       .      .    template <class _InputIterator>
            .    .    .             .           .       .           .       .      .      vector(_InputIterator __first, _InputIterator __last,
            .    .    .             .           .       .           .       .      .             const allocator_type& __a = allocator_type())
            .    .    .             .           .       .           .       .      .  	: _Base(__a)
            .    .    .             .           .       .           .       .      .  	{
-- line 353 ----------------------------------------
-- line 367 ----------------------------------------
            .    .    .             .           .       .           .       .      .      void
            .    .    .             .           .       .           .       .      .  	_M_initialize_aux(_InputIterator __first, _InputIterator __last, __false_type)
            .    .    .             .           .       .           .       .      .  	{
            .    .    .             .           .       .           .       .      .  	  typedef typename iterator_traits<_InputIterator>::iterator_category _IterCategory;
            .    .    .             .           .       .           .       .      .  	  _M_range_initialize(__first, __last, _IterCategory());
            .    .    .             .           .       .           .       .      .  	}
            .    .    .             .           .       .           .       .      .  
            .    .    .             .           .       .           .       .      .    ~vector()
      147,432    7    4        40,979           0       0      57,316       1      0    { _Destroy(_M_start, _M_finish); }
            .    .    .             .           .       .           .       .      .  
            .    .    .             .           .       .           .       .      .    vector<_Tp, _Alloc>& operator=(const vector<_Tp, _Alloc>& __x);
            .    .    .             .           .       .           .       .      .  
            .    .    .             .           .       .           .       .      .    /**
            .    .    .             .           .       .           .       .      .     *  @brief  Attempt to preallocate enough memory for specified number of
            .    .    .             .           .       .           .       .      .     *          elements.
            .    .    .             .           .       .           .       .      .     *  @param  n  Number of elements required
            .    .    .             .           .       .           .       .      .     *
-- line 383 ----------------------------------------
-- line 484 ----------------------------------------
            .    .    .             .           .       .           .       .      .     *
            .    .    .             .           .       .           .       .      .     *  This is a typical stack operation.  The function creates an element at
            .    .    .             .           .       .           .       .      .     *  the end of the vector and assigns the given data to it.
            .    .    .             .           .       .           .       .      .     *  Due to the nature of a vector this operation can be done in constant
            .    .    .             .           .       .           .       .      .     *  time if the vector has preallocated space available.
            .    .    .             .           .       .           .       .      .    */
            .    .    .             .           .       .           .       .      .    void
            .    .    .             .           .       .           .       .      .    push_back(const _Tp& __x)
      177,637    4    4        63,853          35       2      49,931      40      1    {
      207,889    3    1       128,910       3,413       2           .       .      .      if (_M_finish != _M_end_of_storage) {
            .    .    .             .           .       .           .       .      .        _Construct(_M_finish, __x);
      127,017  178    0        41,847           0       0      35,337       0      0        ++_M_finish;
            .    .    .             .           .       .           .       .      .      }
            .    .    .             .           .       .           .       .      .      else
            .    .    .             .           .       .           .       .      .        _M_insert_aux(end(), __x);
            .    .    .             .           .       .           .       .      .    }
            .    .    .             .           .       .           .       .      .  
            .    .    .             .           .       .           .       .      .  #ifdef _GLIBCPP_DEPRECATED
            .    .    .             .           .       .           .       .      .    /**
            .    .    .             .           .       .           .       .      .     *  Add an element to the end of the vector.  The element is
-- line 503 ----------------------------------------
-- line 607 ----------------------------------------
            .    .    .             .           .       .           .       .      .     *
            .    .    .             .           .       .           .       .      .     *  This function will insert a specified number of copies of the given data
            .    .    .             .           .       .           .       .      .     *  into the specified location.
            .    .    .             .           .       .           .       .      .     *
            .    .    .             .           .       .           .       .      .     *  Note that this kind of operation could be expensive for a vector and if
            .    .    .             .           .       .           .       .      .     *  it is frequently used the user should consider using std::list.
            .    .    .             .           .       .           .       .      .    */
            .    .    .             .           .       .           .       .      .    void insert (iterator __pos, size_type __n, const _Tp& __x)
           20    3    1             6           1       1          12       0      0      { _M_fill_insert(__pos, __n, __x); }
            .    .    .             .           .       .           .       .      .  
            .    .    .             .           .       .           .       .      .    void _M_fill_insert (iterator __pos, size_type __n, const _Tp& __x);
            .    .    .             .           .       .           .       .      .  
            .    .    .             .           .       .           .       .      .    /**
            .    .    .             .           .       .           .       .      .     *  @brief  Removes last element from vector.
            .    .    .             .           .       .           .       .      .     *
            .    .    .             .           .       .           .       .      .     *  This is a typical stack operation. It allows us to shrink the vector by
            .    .    .             .           .       .           .       .      .     *  one.
-- line 623 ----------------------------------------
-- line 695 ----------------------------------------
            .    .    .             .           .       .           .       .      .     *  @brief  Resizes the vector to the specified number of elements.
            .    .    .             .           .       .           .       .      .     *  @param  new_size  Number of elements the vector should contain.
            .    .    .             .           .       .           .       .      .     *
            .    .    .             .           .       .           .       .      .     *  This function will resize the vector to the specified number of
            .    .    .             .           .       .           .       .      .     *  elements.  If the number is smaller than the vector's current size the
            .    .    .             .           .       .           .       .      .     *  vector is truncated, otherwise the vector is extended and new elements
            .    .    .             .           .       .           .       .      .     *  are left uninitialized.
            .    .    .             .           .       .           .       .      .    */
            8    1    1             4           0       0           2       0      0    void resize(size_type __new_size) { resize(__new_size, _Tp()); }
            .    .    .             .           .       .           .       .      .  
            .    .    .             .           .       .           .       .      .    /**
            .    .    .             .           .       .           .       .      .     *  Erases all elements in vector.  Note that this function only erases the
            .    .    .             .           .       .           .       .      .     *  elements, and that if the elements themselves are pointers, the
            .    .    .             .           .       .           .       .      .     *  pointed-to memory is not touched in any way.  Managing the pointer is
            .    .    .             .           .       .           .       .      .     *  the user's responsibilty.
            .    .    .             .           .       .           .       .      .    */
            .    .    .             .           .       .           .       .      .    void clear() { erase(begin(), end()); }
            .    .    .             .           .       .           .       .      .  
            .    .    .             .           .       .           .       .      .  protected:
            .    .    .             .           .       .           .       .      .  
            .    .    .             .           .       .           .       .      .    template <class _ForwardIterator>
            .    .    .             .           .       .           .       .      .    pointer _M_allocate_and_copy(size_type __n, _ForwardIterator __first,
            .    .    .             .           .       .           .       .      .                                                 _ForwardIterator __last)
           18    1    1             2           0       0          10       0      0    {
            .    .    .             .           .       .           .       .      .      pointer __result = _M_allocate(__n);
            .    .    .             .           .       .           .       .      .      try {
            .    .    .             .           .       .           .       .      .        uninitialized_copy(__first, __last, __result);
           14    0    0            12           2       2           .       .      .        return __result;
            .    .    .             .           .       .           .       .      .      }
            .    .    .             .           .       .           .       .      .      catch(...)
            .    .    .             .           .       .           .       .      .        {
            .    .    .             .           .       .           .       .      .  	_M_deallocate(__result, __n);
            .    .    .             .           .       .           .       .      .  	__throw_exception_again;
            .    .    .             .           .       .           .       .      .        }
            .    .    .             .           .       .           .       .      .    }
            .    .    .             .           .       .           .       .      .  
-- line 730 ----------------------------------------
-- line 802 ----------------------------------------
            .    .    .             .           .       .           .       .      .  inline bool
            .    .    .             .           .       .           .       .      .  operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y) {
            .    .    .             .           .       .           .       .      .    return !(__x < __y);
            .    .    .             .           .       .           .       .      .  }
            .    .    .             .           .       .           .       .      .  
            .    .    .             .           .       .           .       .      .  template <class _Tp, class _Alloc>
            .    .    .             .           .       .           .       .      .  vector<_Tp,_Alloc>&
            .    .    .             .           .       .           .       .      .  vector<_Tp,_Alloc>::operator=(const vector<_Tp, _Alloc>& __x)
           18    1    1             2           0       0          10       0      0  {
            4    0    0             2           0       0           .       .      .    if (&__x != this) {
            .    .    .             .           .       .           .       .      .      const size_type __xlen = __x.size();
            .    .    .             .           .       .           .       .      .      if (__xlen > capacity()) {
            .    .    .             .           .       .           .       .      .        pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(), __x.end());
            .    .    .             .           .       .           .       .      .        _Destroy(_M_start, _M_finish);
            .    .    .             .           .       .           .       .      .        _M_deallocate(_M_start, _M_end_of_storage - _M_start);
            4    0    0             2           0       0           2       0      0        _M_start = __tmp;
           12    0    0             4           0       0           2       0      0        _M_end_of_storage = _M_start + __xlen;
            .    .    .             .           .       .           .       .      .      }
            .    .    .             .           .       .           .       .      .      else if (size() >= __xlen) {
            .    .    .             .           .       .           .       .      .        iterator __i(copy(__x.begin(), __x.end(), begin()));
            .    .    .             .           .       .           .       .      .        _Destroy(__i, end());
            .    .    .             .           .       .           .       .      .      }
            .    .    .             .           .       .           .       .      .      else {
            .    .    .             .           .       .           .       .      .        copy(__x.begin(), __x.begin() + size(), _M_start);
            .    .    .             .           .       .           .       .      .        uninitialized_copy(__x.begin() + size(), __x.end(), _M_finish);
            .    .    .             .           .       .           .       .      .      }
           10    2    2             4           0       0           2       0      0      _M_finish = _M_start + __xlen;
            .    .    .             .           .       .           .       .      .    }
           14    0    0            10           0       0           .       .      .    return *this;
            .    .    .             .           .       .           .       .      .  }
            .    .    .             .           .       .           .       .      .  
            .    .    .             .           .       .           .       .      .  template <class _Tp, class _Alloc>
            .    .    .             .           .       .           .       .      .  void vector<_Tp, _Alloc>::_M_fill_assign(size_t __n, const value_type& __val)
            .    .    .             .           .       .           .       .      .  {
            .    .    .             .           .       .           .       .      .    if (__n > capacity()) {
            .    .    .             .           .       .           .       .      .      vector<_Tp, _Alloc> __tmp(__n, __val, get_allocator());
            .    .    .             .           .       .           .       .      .      __tmp.swap(*this);
-- line 838 ----------------------------------------
-- line 881 ----------------------------------------
            .    .    .             .           .       .           .       .      .      copy(__first, __mid, _M_start);
            .    .    .             .           .       .           .       .      .      _M_finish = uninitialized_copy(__mid, __last, _M_finish);
            .    .    .             .           .       .           .       .      .    }
            .    .    .             .           .       .           .       .      .  }
            .    .    .             .           .       .           .       .      .  
            .    .    .             .           .       .           .       .      .  template <class _Tp, class _Alloc>
            .    .    .             .           .       .           .       .      .  void
            .    .    .             .           .       .           .       .      .  vector<_Tp, _Alloc>::_M_insert_aux(iterator __position, const _Tp& __x)
       14,024   61    5             .           .       .       8,765       0      0  {
        8,835    2    1         5,329           0       0           .       .      .    if (_M_finish != _M_end_of_storage) {
            .    .    .             .           .       .           .       .      .      _Construct(_M_finish, *(_M_finish - 1));
            .    .    .             .           .       .           .       .      .      ++_M_finish;
            .    .    .             .           .       .           .       .      .      _Tp __x_copy = __x;
            .    .    .             .           .       .           .       .      .      copy_backward(__position, iterator(_M_finish - 2), iterator(_M_finish- 1));
    1,268,064    8    6       624,824           6       0     643,226       0      0      *__position = __x_copy;
            .    .    .             .           .       .           .       .      .    }
            .    .    .             .           .       .           .       .      .    else {
            .    .    .             .           .       .           .       .      .      const size_type __old_size = size();
        9,880   28    1             .           .       .       3,208      19      1      const size_type __len = __old_size != 0 ? 2 * __old_size : 1;
            .    .    .             .           .       .           .       .      .      iterator __new_start(_M_allocate(__len));
           70   28    1            70           0       0           .       .      .      iterator __new_finish(__new_start);
            .    .    .             .           .       .           .       .      .      try {
            .    .    .             .           .       .           .       .      .        __new_finish = uninitialized_copy(iterator(_M_start), __position,
            .    .    .             .           .       .           .       .      .                                          __new_start);
            .    .    .             .           .       .           .       .      .        _Construct(__new_finish.base(), __x);
            .    .    .             .           .       .           .       .      .        ++__new_finish;
            .    .    .             .           .       .           .       .      .        __new_finish = uninitialized_copy(__position, iterator(_M_finish),
            .    .    .             .           .       .           .       .      .                                          __new_finish);
            .    .    .             .           .       .           .       .      .      }
-- line 909 ----------------------------------------
-- line 912 ----------------------------------------
            .    .    .             .           .       .           .       .      .  	_Destroy(__new_start,__new_finish);
            .    .    .             .           .       .           .       .      .  	_M_deallocate(__new_start.base(),__len);
            .    .    .             .           .       .           .       .      .  	__throw_exception_again;
            .    .    .             .           .       .           .       .      .        }
            .    .    .             .           .       .           .       .      .      _Destroy(begin(), end());
            .    .    .             .           .       .           .       .      .      _M_deallocate(_M_start, _M_end_of_storage - _M_start);
            .    .    .             .           .       .           .       .      .      _M_start = __new_start.base();
            .    .    .             .           .       .           .       .      .      _M_finish = __new_finish.base();
       10,518   31    4         8,765          12       4           .       .      .      _M_end_of_storage = __new_start.base() + __len;
            .    .    .             .           .       .           .       .      .    }
            .    .    .             .           .       .           .       .      .  }
            .    .    .             .           .       .           .       .      .  
            .    .    .             .           .       .           .       .      .  template <class _Tp, class _Alloc>
            .    .    .             .           .       .           .       .      .  void
            .    .    .             .           .       .           .       .      .  vector<_Tp, _Alloc>::_M_insert_aux(iterator __position)
            .    .    .             .           .       .           .       .      .  {
            .    .    .             .           .       .           .       .      .    if (_M_finish != _M_end_of_storage) {
-- line 928 ----------------------------------------
-- line 957 ----------------------------------------
            .    .    .             .           .       .           .       .      .      _M_finish = __new_finish;
            .    .    .             .           .       .           .       .      .      _M_end_of_storage = __new_start + __len;
            .    .    .             .           .       .           .       .      .    }
            .    .    .             .           .       .           .       .      .  }
            .    .    .             .           .       .           .       .      .  
            .    .    .             .           .       .           .       .      .  template <class _Tp, class _Alloc>
            .    .    .             .           .       .           .       .      .  void vector<_Tp, _Alloc>::_M_fill_insert(iterator __position, size_type __n,
            .    .    .             .           .       .           .       .      .                                           const _Tp& __x)
           16    3    2             .           .       .          10       0      0  {
            6    1    0             2           0       0           .       .      .    if (__n != 0) {
           15    1    1             6           0       0           .       .      .      if (size_type(_M_end_of_storage - _M_finish) >= __n) {
            .    .    .             .           .       .           .       .      .        _Tp __x_copy = __x;
            .    .    .             .           .       .           .       .      .        const size_type __elems_after = end() - __position;
            .    .    .             .           .       .           .       .      .        iterator __old_finish(_M_finish);
            .    .    .             .           .       .           .       .      .        if (__elems_after > __n) {
            .    .    .             .           .       .           .       .      .          uninitialized_copy(_M_finish - __n, _M_finish, _M_finish);
            .    .    .             .           .       .           .       .      .          _M_finish += __n;
            .    .    .             .           .       .           .       .      .          copy_backward(__position, __old_finish - __n, __old_finish);
            .    .    .             .           .       .           .       .      .          fill(__position, __position + __n, __x_copy);
-- line 975 ----------------------------------------
-- line 981 ----------------------------------------
            .    .    .             .           .       .           .       .      .          _M_finish += __elems_after;
            .    .    .             .           .       .           .       .      .          fill(__position, __old_finish, __x_copy);
            .    .    .             .           .       .           .       .      .        }
            .    .    .             .           .       .           .       .      .      }
            .    .    .             .           .       .           .       .      .      else {
            .    .    .             .           .       .           .       .      .        const size_type __old_size = size();
            .    .    .             .           .       .           .       .      .        const size_type __len = __old_size + max(__old_size, __n);
            .    .    .             .           .       .           .       .      .        iterator __new_start(_M_allocate(__len));
            2    2    2             2           0       0           .       .      .        iterator __new_finish(__new_start);
            .    .    .             .           .       .           .       .      .        try {
            .    .    .             .           .       .           .       .      .          __new_finish = uninitialized_copy(begin(), __position, __new_start);
            .    .    .             .           .       .           .       .      .          __new_finish = uninitialized_fill_n(__new_finish, __n, __x);
            .    .    .             .           .       .           .       .      .          __new_finish
            .    .    .             .           .       .           .       .      .            = uninitialized_copy(__position, end(), __new_finish);
            .    .    .             .           .       .           .       .      .        }
            .    .    .             .           .       .           .       .      .        catch(...)
            .    .    .             .           .       .           .       .      .  	{
-- line 997 ----------------------------------------
-- line 998 ----------------------------------------
            .    .    .             .           .       .           .       .      .  	  _Destroy(__new_start,__new_finish);
            .    .    .             .           .       .           .       .      .  	  _M_deallocate(__new_start.base(),__len);
            .    .    .             .           .       .           .       .      .  	  __throw_exception_again;
            .    .    .             .           .       .           .       .      .  	}
            .    .    .             .           .       .           .       .      .        _Destroy(_M_start, _M_finish);
            .    .    .             .           .       .           .       .      .        _M_deallocate(_M_start, _M_end_of_storage - _M_start);
            .    .    .             .           .       .           .       .      .        _M_start = __new_start.base();
            .    .    .             .           .       .           .       .      .        _M_finish = __new_finish.base();
           12    2    1            10           0       0           .       .      .        _M_end_of_storage = __new_start.base() + __len;
            .    .    .             .           .       .           .       .      .      }
            .    .    .             .           .       .           .       .      .    }
            .    .    .             .           .       .           .       .      .  }
            .    .    .             .           .       .           .       .      .  
            .    .    .             .           .       .           .       .      .  template <class _Tp, class _Alloc> template <class _InputIterator>
            .    .    .             .           .       .           .       .      .  void
            .    .    .             .           .       .           .       .      .  vector<_Tp, _Alloc>::_M_range_insert(iterator __pos,
            .    .    .             .           .       .           .       .      .                                       _InputIterator __first,
-- line 1014 ----------------------------------------

--------------------------------------------------------------------------------
Ir I1mr I2mr Dr D1mr D2mr Dw D1mw D2mw 
--------------------------------------------------------------------------------
57    1    2 49   95   61 69   55   27  percentage of events annotated

